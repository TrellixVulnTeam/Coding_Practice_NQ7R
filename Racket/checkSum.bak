#lang racket
(require "numberConverter.rkt")

(define (numDigits n)
  (length (string->list (number->string n))))

(define (checkSum lst)
  "hey")

(define (binAdd a b)
  (let* ([a (baseConverter a 10 2)]
         [lengthA (numDigits a)]
         [lengthB (numDigits b)]
         [listA (number->list a)]
         [listB (number->list b)])
    (cond
      [(< lengthA lengthB) (set! listA (append (pad (- lengthB lengthA)) listA))]
      [(> lengthA lengthB) (set! listB (append (pad (- lengthA lengthB)) listB))])
    (map (lambda (x y) (+ x y)) listA listB)))
;  (define (helper n i acc)
;    (let ([digit (modulo (* (expt 2 i)))])))
;  )

;(map2 (lambda (x y) (+ x y)) listA listB)

(define (pad n)
  (build-list n (lambda (x) (* x 0))))

(define (number->list n)
  (let ([n
         (map
          (lambda (x) (- (char->integer x) 48))
          (reverse (string->list (number->string n))))])
    (reverse n)))

(define (list->number lst)
  (define (helper lst n i)
    (cond
      [(empty? lst) n]
      [else (helper (rest lst) (+ n (* (first lst) (expt 10 i))) (add1 i))]))
  (helper (reverse lst) 0 0))